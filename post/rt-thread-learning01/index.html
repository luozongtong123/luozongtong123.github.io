<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>RT-Thread 学习（一） - luo Space - Coding and thinking.</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="luo" />
  <meta name="description" content="野火出了本书 ————《RT-Thread 内核实现与应用开发实战指南》，这本书基于 STM32 讲解了 RT-Thread 内核的实现以及 RT-Thread 内核应用开发。现在结合这本书学习一下 RT-Thread。这是这一系列学习笔记的第一篇。 " />

  <meta name="keywords" content="coding, thinking" />






<meta name="generator" content="Hugo 0.43" />


<link rel="canonical" href="https://luozongtong123.github.io/post/rt-thread-learning01/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="RT-Thread 学习（一）" />
<meta property="og:description" content="野火出了本书 ————《RT-Thread 内核实现与应用开发实战指南》，这本书基于 STM32 讲解了 RT-Thread 内核的实现以及 RT-Thread 内核应用开发。现在结合这本书学习一下 RT-Thread。这是这一系列学习笔记的第一篇。
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://luozongtong123.github.io/post/rt-thread-learning01/" />



<meta property="article:published_time" content="2018-09-29T09:37:14&#43;08:00"/>

<meta property="article:modified_time" content="2018-10-02T22:00:14&#43;08:00"/>











<meta itemprop="name" content="RT-Thread 学习（一）">
<meta itemprop="description" content="野火出了本书 ————《RT-Thread 内核实现与应用开发实战指南》，这本书基于 STM32 讲解了 RT-Thread 内核的实现以及 RT-Thread 内核应用开发。现在结合这本书学习一下 RT-Thread。这是这一系列学习笔记的第一篇。
">


<meta itemprop="datePublished" content="2018-09-29T09:37:14&#43;08:00" />
<meta itemprop="dateModified" content="2018-09-29T09:37:14&#43;08:00" />
<meta itemprop="wordCount" content="5085">



<meta itemprop="keywords" content="RT-Thread,线程,栈," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="RT-Thread 学习（一）"/>
<meta name="twitter:description" content="野火出了本书 ————《RT-Thread 内核实现与应用开发实战指南》，这本书基于 STM32 讲解了 RT-Thread 内核的实现以及 RT-Thread 内核应用开发。现在结合这本书学习一下 RT-Thread。这是这一系列学习笔记的第一篇。
"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">luo Space</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/project/">
        <li class="mobile-menu-item">项目</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">luo Space</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/project/">项目</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">RT-Thread 学习（一）</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-09-29 </span>
        
        <span class="more-meta"> 约 5085 字 </span>
        <span class="more-meta"> 预计阅读 11 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#裸机与多线程">裸机与多线程</a>
<ul>
<li><a href="#裸机系统">裸机系统</a></li>
<li><a href="#多线程系统">多线程系统</a></li>
</ul></li>
<li><a href="#线程与线程的创建">线程与线程的创建</a>
<ul>
<li><a href="#定义线程栈">定义线程栈</a></li>
<li><a href="#定义线程函数">定义线程函数</a></li>
<li><a href="#定义线程控制块">定义线程控制块</a></li>
<li><a href="#section-rt_thread_init">线程创建函数的实现</a>
<ul>
<li><a href="#在双向链表表头后面插入一个节点">在双向链表表头后面插入一个节点</a></li>
<li><a href="#在双向链表表头前面插入一个节点">在双向链表表头前面插入一个节点</a></li>
<li><a href="#从双向链表删除一个节点">从双向链表删除一个节点</a></li>
<li><a href="#rt-hw-stack-init-函数">rt_hw_stack_init()函数</a></li>
</ul></li>
</ul></li>
<li><a href="#实现就绪列表">实现就绪列表</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>野火出了本书 ————《RT-Thread 内核实现与应用开发实战指南》，这本书基于 STM32 讲解了 RT-Thread 内核的实现以及 RT-Thread 内核应用开发。现在结合这本书学习一下 RT-Thread。这是这一系列学习笔记的第一篇。
</p>

<p>电子版的书和工程源文件以及参考资料下载链接如下：</p>

<p>链接: <a href="https://pan.baidu.com/s/1VxToy8wi6Lg5ozhrNqgXRA">点击直达</a>  提取码: mqrb</p>

<h1 id="裸机与多线程">裸机与多线程</h1>

<p>最开始学习单片机的时候大家都是直接跑裸机不使用操作系统，裸机的优势是不需要学习操作系统的知识，当实现一个简单的程序时裸机简单快捷。当系统的 Flash 和 ROM 资源紧张时，裸机可以节省一部分资源。</p>

<h2 id="裸机系统">裸机系统</h2>

<p>裸机程序分为轮询系统和加入中断的前后台系统。轮询系统就是程序在主函数中有一个死循环不断执行某些任务。轮询系统只能被动有延时地处理外界对系统的影响无法主动实时地对外界变化多处反应。为了提供系统的响应实时性，引入了中断机制。</p>

<p>回顾一下中断机制：CPU 在执行每一条指令后会确认刚才执行指令期间是否有中断请求过来，如果有中断请求则 CPU 会中断当前程序的执行，保存程序的现场（一些寄存器压栈 push），然后跳转到对应的中断服务函数并执行中断服务函数，中断服务函数执行完毕后出栈，恢复程序的执行。</p>

<p>引入了中断机制的轮询系统称为前后台系统，其中中断执行的过程为前台，主函数中的轮询为后台。前后台系统确保了外部事件不会丢失并能够得到及时的响应。在大多数中小型系统中前后台系统应用的得当的话可以得到堪比加入了操作系统的效果。</p>

<p>相比于前后台系统，多线程系统对外部事件的响应也是在中断中完成的，但是事件的处理是在线程中完成的。在多线程系统中，线程跟中断一样，也具有优先级，优先级高的线程会被优先执行。当一个紧急的事件在中断被标记之后，如果事件对应的线程的优先级足够高，就会立马得到响应。相比前后台系统，多线程系统的实时性又被提高了。</p>

<h2 id="多线程系统">多线程系统</h2>

<p>在多线程系统中，我们根据不同的功能将程序分为多个小的独立的无限循环的任务，这个任务称为线程。每个线程独立、互不干扰、且拥有自己的优先级，线程由实时操作系统进行调度的管理。加入操作系统后我们就不需要精心设计程序流，只需要设计好各个进行的逻辑和不同进程间的通信即可，对大型系统而言，加入了操作系统会使系统的可维护性更好。</p>

<p>关于上不上操作系统从来就不是一个确定的问题，这需要根据实际的需求来决定。如果只是一个简单的系统，强行加入操作系统只会增加开发和维护的难度。</p>

<h1 id="线程与线程的创建">线程与线程的创建</h1>

<p>前面讲到，在裸机系统中，系统的主体就是 main 函数里面顺序执行的无限循环，这个无限循环里面 CPU 按照顺序完成各种事情。在多线程系统中，我们根据功能的不同，把整个系统分割成一个个独立的且无法返回的函数，这个函数我们称为线程。</p>

<h2 id="定义线程栈">定义线程栈</h2>

<p>在裸机系统中，自动局部变量是存储在栈上的，栈的管理是由 C 语言编译器来完成的，栈的初始化一般是在启动文件中或者是在链接命中指定，然后由 C 语言的 <code>_main</code>来完成初始化的操作。逻辑系统中，整个程序只有一个栈，多个函数调用的过程中就对这个栈进行压栈和出栈操作。对于有 RTOS 的系统来言，我们要实现线程间的隔离就需要为每个线程创建独立的栈，在该线程内的函数调用只需要对线程自己的栈进行操作。</p>

<p>这个由进程使用的栈一般是一个预先定义的一个全局数组或者一段动态分配的内存。</p>

<pre><code class="language-c">/* 设置字节对齐 */
ALIGN(RT_ALIGN_SIZE) (2)
/* 定义线程栈 */
rt_uint8_t rt_flag1_thread_stack[512];
rt_uint8_t rt_flag2_thread_stack[512];
</code></pre>

<p><code>rt_uint8_t</code>是在 <code>rtdef.h</code> 中定义的类型，其他会用到的数据类型详见<a href="/src/rt-thread-learning01/rtdef.h">这里</a>。</p>

<h2 id="定义线程函数">定义线程函数</h2>

<pre><code class="language-c">/* 软件延时 */
void delay (uint32_t count)
{
    for(; count!=0; count--);
}

/* 线程1 */
void flag1_thread_entry( void *p_arg )
{
    for( ;; )
    {
        flag1 = 1;
        delay( 100 );       
        flag1 = 0;
        delay( 100 );
        
        /* 线程切换，这里是手动切换 */      
        rt_schedule();
    }
}

/* 线程2 */
void flag2_thread_entry( void *p_arg )
{
    for( ;; )
    {
        flag2 = 1;
        delay( 100 );       
        flag2 = 0;
        delay( 100 );
        
        /* 线程切换，这里是手动切换 */
        rt_schedule();
    }
}

</code></pre>

<p>如前文所述，线程是一个独立的、无限循环且不能返回的函数。</p>

<h2 id="定义线程控制块">定义线程控制块</h2>

<p>线程控制块是一个线程的标识，线程调度器通过现称快隋朝块识别调度线程，线程控制块的定义如下：</p>

<pre><code class="language-c">struct rt_thread
{
    void        *sp;              /* 线程栈指针 */
    void        *entry;           /* 线程入口地址 */
    void        *parameter;       /* 线程形参 */    
    void        *stack_addr;      /* 线程起始地址 */
    rt_uint32_t stack_size;       /* 线程栈大小，单位为字节 */
    
    rt_list_t   tlist;            /* 线程链表节点 */
};
typedef struct rt_thread *rt_thread_t;
</code></pre>

<p>在 RT-Thread 中，都会给新声明的数据结构重新定义一个指针。往后如果要定义线程控制块变量就使用  <code>struct rt_thread xxx</code> 的形式，定义线程控制块指针就使用 <code>rt_thread_t xxx</code> 的形式。</p>

<h2 id="section-rt_thread_init">线程创建函数的实现</h2>

<p>创建线程就是根据给出的参数如线程的名称、线程栈的大小等完成线程栈的初始化和线程控制块的初始化。线程的创建由函数 <code>rt_thread_init()</code> 来实现，该函数在 <code>thread.c</code> 中定义在 <code>rthread.h</code> 中声明。该函数的实现如下：</p>

<pre><code class="language-c">rt_err_t rt_thread_init(struct rt_thread *thread,        // 线程控制块
                        void (*entry)(void *parameter),  // 线程函数名即线程入口
                        void             *parameter,     // 线程形参
                        void             *stack_start,   // 线程栈起始地址
                        rt_uint32_t       stack_size)    // 线程栈大小
{
    rt_list_init(&amp;(thread-&gt;tlist));                      // (1)
    
    thread-&gt;entry = (void *)entry;    // 将线程入口保存到线程控制块的 entry成员中
    thread-&gt;parameter = parameter;    // 将线程入口形参保存到线程控制块的 parameter 成员中

    thread-&gt;stack_addr = stack_start; // 将线程栈起始地址保存到线程控制块的 stack_start 成员中
    thread-&gt;stack_size = stack_size;  // 将线程栈起大小保存到线程控制块的 stack_size成员中
    
    /* 初始化线程栈，并返回线程栈指针 */
    thread-&gt;sp = (void *)rt_hw_stack_init( thread-&gt;entry, 
                                           thread-&gt;parameter,
                                           (void *)((char *)thread-&gt;stack_addr + thread-&gt;stack_size - 4) );
    
    return RT_EOK;
}
</code></pre>

<p>标号为 (1) 的代码对线程控制块的线程链表节点 <code>tlist</code> 进行初始化，链表节点可以插入到不同的链表，线程调度器通过链表调度线程。<code>tlist</code> 的数据原型是 <code>rt_list_t</code> 。</p>

<blockquote>
<p><strong>此处有个问题，线程控制块链表节点初始化的目的是什么？</strong></p>
</blockquote>

<p>双向链表节点数据类型定义如下：</p>

<pre><code class="language-c">struct rt_list_node
{
  struct rt_list_node *next;   /* 指向后一个节点 */
  struct rt_list_node *prev;   /* 指向前一个节点 */
};
typedef struct rt_list_node rt_list_t;
</code></pre>

<p>节点中包含两个数据第一个是指向下一个节点的指针，第二个是指向上一个节点的指针。</p>

<p>关于这个节点的作用书中在此处没有说明，他的作用是在后面讲的，我们把这部分拿到前面来。前面讲到我们可以把 <code>tlist</code> 这个线程控制块的成员插入到不同的链表中，例如就绪列表等。线程调度器再根据列表中的节点切换不同的线程，那么问题来了，我们如何利用这个节点找到线程控制块呢？ RT-Thread 中有一个宏可以通过 <code>tlist</code> 来找到线程控制块的起始地址，这个宏是 <code>rt_list_entry()</code> ，其定义如下：</p>

<pre><code class="language-c">/* 已知一个结构体里面的成员的地址，反推出该结构体的首地址 */
#define rt_container_of(ptr, type, member)
    ((type *)((char *)(ptr) - (unsigned long)(&amp;((type *)0)-&gt;member)))

#define rt_list_entry(node, type, member)
    rt_container_of(node, type, member)
</code></pre>

<p><code>rt_list_entry()</code> 调用了 <code>rt_container_of()</code> 宏，这个宏可以已知结构体中的成员找到结构体的首地址。上述代码中， <code>prt</code> 是指向结构体成员的地址， <code>type</code> 是结构体的类型， <code>member</code> 是结构体成员的名字。我们来看一下这个宏函数。</p>


<figure class="center">
    
        <img src="/img/rt-thread-learning01/rt_container_of.jpg" alt="rt_container_of() 宏的实现" />
    
    
    <figcaption>
        <h4>rt_container_of() 宏的实现</h4>
        
    </figcaption>
    
</figure>


<p>如上图左半边图所示，我们已知 <code>prt</code> 要求 <code>f_struct_prt</code> ，显然只要知道深色部分标注为<strong>偏移</strong>的大小即可。那么如何才能求出偏移量的大小呢，这需要借助于 <strong>0 地址</strong>。</p>

<ol>
<li><p>首先，将 0 地址强制转换为 <code>type</code> 类型的结构体： <code>((type *)0)</code>，</p></li>

<li><p>然后，获取到这个结构体的成员 <code>member</code> 的地址： <code>(&amp;((type *)0)-&gt;member))</code>，</p></li>

<li><p>最后，因为这个结构体的起始地址是 0 ，所以只要将这个成员的地址强制转换成无符号长整型数就是我们要求的偏移： <code>(unsigned long)(&amp;((type *)0)-&gt;member))</code>。</p></li>
</ol>

<p>再回到 <code>(char *)(ptr)</code> ，这里将指针强制转换为 <code>char</code> 的目的是为了在后面加减偏移量时以一个字节为单位。最后的最后，再将减去偏移量的地址强制转换为结构体类型的指针。至于 <code>rt_list_entry()</code> ，则可以非常容易的理解为，已知节点地址 <code>node</code> 、线程控制块结构体类型 <code>type</code> 、节点名称（tlist） <code>member</code> ，求线程控制块的地址。</p>

<p>讲完了节点的作用下面我们来看一下节点双向列表的一些操作。</p>

<p>由上面给出的节点的定义可知，由节点构成的链表可以表示成下图：</p>


<figure class="center">
    
        <img src="/img/rt-thread-learning01/list_of_rt_list_t.jpg" alt="rt_list_t列表" />
    
    
    <figcaption>
        <h4>rt_list_t列表</h4>
        
    </figcaption>
    
</figure>


<p>链表的操作包括初始化链表节点、在双向链表表头前面插入一个节点、在双向链表表头后面插入一个节点、从双向链表中删除一个节点。相关函数的实现在 <code>rtservice.h</code> 。</p>

<p><strong>初始化链表节点</strong></p>

<p>rt_list_t 类型的节点的初始化，就是将节点里面的 next 和 prev 这两个节点指针指向节点本身。代码实现如下：</p>

<pre><code class="language-c">rt_inline void rt_list_init(rt_list_t *l)
{
    l-&gt;next = l-&gt;prev = l;
}
</code></pre>


<figure class="center">
    
        <img src="/img/rt-thread-learning01/list_op_1.jpg" alt="初始化链表节点" />
    
    
    <figcaption>
        <h4>初始化链表节点</h4>
        
    </figcaption>
    
</figure>


<h3 id="在双向链表表头后面插入一个节点">在双向链表表头后面插入一个节点</h3>

<blockquote>
<p>此处的表头的表述是否有问题，因为从双向链表的结构来看，双向链表没有所谓的表头？</p>

<p>是否应该说 向双向链表的 <code>l</code> 节点后插入 <code>n</code> ？</p>
</blockquote>

<p>插入节点一共需要四步操作，即图示四个红色箭头的操作，将这四步操作转换为代码则是下面的代码中四步。仔细观察这四步操作，不难发现，如果要保证代码完成我们想要的操作，代码执行的前后顺序是有要求的。即：第三步对 <code>l-&gt;next</code> 的赋值操作要在第一步和第二部对其引用之后。只要保证这个前后关系满足要求即可。</p>

<p>代码中采用这种顺序实现起来更加 <del>优雅</del> 并不。</p>

<pre><code class="language-c">/* 在双向链表头部插入一个节点 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
    l-&gt;next-&gt;prev = n;   /* 第1步 */
    n-&gt;next = l-&gt;next;   /* 第2步 */
    
    l-&gt;next = n;         /* 第3步 */
    n-&gt;prev = l;         /* 第4步 */
}
</code></pre>


<figure class="center">
    
        <img src="/img/rt-thread-learning01/list_op_2.jpg" alt="在双向链表表头后面插入一个节点" />
    
    
    <figcaption>
        <h4>在双向链表表头后面插入一个节点</h4>
        
    </figcaption>
    
</figure>


<h3 id="在双向链表表头前面插入一个节点">在双向链表表头前面插入一个节点</h3>

<p>不难理解只需要将后插操作代码中的的 <code>prev</code> 和 <code>next</code> 调换一下就可以完成前插操作。</p>

<pre><code class="language-c">rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
    l-&gt;prev-&gt;next = n;   /* 第1步 */
    n-&gt;prev = l-&gt;prev;   /* 第2步 */
    
    l-&gt;prev = n;         /* 第3步 */
    n-&gt;next = l;         /* 第4步 */
}
</code></pre>


<figure class="center">
    
        <img src="/img/rt-thread-learning01/list_op_3.jpg" alt="在双向链表表头前面插入一个节点" />
    
    
    <figcaption>
        <h4>在双向链表表头前面插入一个节点</h4>
        
    </figcaption>
    
</figure>


<h3 id="从双向链表删除一个节点">从双向链表删除一个节点</h3>

<p>删除操作较插入操作要简单一些，只需要注意第三步在前两步之后即可。</p>

<pre><code class="language-c">rt_inline void rt_list_remove(rt_list_t *n)
{
    n-&gt;next-&gt;prev = n-&gt;prev;  /* 第1步 */
    n-&gt;prev-&gt;next = n-&gt;next;  /* 第2步 */
    
    n-&gt;next = n-&gt;prev = n;    /* 第3步 */
}
</code></pre>


<figure class="center">
    
        <img src="/img/rt-thread-learning01/list_op_4.jpg" alt="从双向链表删除一个节点" />
    
    
    <figcaption>
        <h4>从双向链表删除一个节点</h4>
        
    </figcaption>
    
</figure>


<h3 id="rt-hw-stack-init-函数">rt_hw_stack_init()函数</h3>

<p><a href="#section-rt_thread_init">rt_thread_init() 函数</a> 中还用到了 <code>rt_hw_stack_init()</code> 函数 ，该函数对线程栈进行初始化，其代码实现如下：</p>

<pre><code class="language-c">/* 线程栈初始化 */
rt_uint8_t *rt_hw_stack_init(void       *tentry,      // 线程入口
                             void       *parameter,   // 线程形参
                             rt_uint8_t *stack_addr)  // 线程栈顶地址
{
    
    
    struct stack_frame *stack_frame;                  // (1)
    rt_uint8_t         *stk;
    unsigned long       i;
    
    
    /* 获取栈顶指针 rt_hw_stack_init 在调用的时候，传给stack_addr的是(栈顶指针)*/
    stk  = stack_addr + sizeof(rt_uint32_t);
    
    /* 让stk指针向下8字节对齐 */
    stk  = (rt_uint8_t *)RT_ALIGN_DOWN((rt_uint32_t)stk, 8);
    
    /* stk指针继续向下移动sizeof(struct stack_frame)个偏移 */
    stk -= sizeof(struct stack_frame);
    
    /* 将stk指针强制转化为stack_frame类型后存到stack_frame */
    stack_frame = (struct stack_frame *)stk;
    
    /* 以stack_frame为起始地址，将栈空间里面的 sizeof(struct stack_frame) 个内存初始化为0xdeadbeef */
    for (i = 0; i &lt; sizeof(struct stack_frame) / sizeof(rt_uint32_t); i ++)
    {
            ((rt_uint32_t *)stack_frame)[i] = 0xdeadbeef;
    }
    
    /* 初始化异常发生时自动保存的寄存器 */
    stack_frame-&gt;exception_stack_frame.r0  = (unsigned long)parameter; /* r0 : argument */
    stack_frame-&gt;exception_stack_frame.r1  = 0;                        /* r1 */
    stack_frame-&gt;exception_stack_frame.r2  = 0;                        /* r2 */
    stack_frame-&gt;exception_stack_frame.r3  = 0;                        /* r3 */
    stack_frame-&gt;exception_stack_frame.r12 = 0;                        /* r12 */
    stack_frame-&gt;exception_stack_frame.lr  = 0;                        /* lr */
    stack_frame-&gt;exception_stack_frame.pc  = (unsigned long)tentry;    /* entry point, pc */
    stack_frame-&gt;exception_stack_frame.psr = 0x01000000L;              /* PSR */
    
    /* 返回线程栈指针 */
    return stk;
}
</code></pre>

<p>代码 <code>(1)</code> 处定义了一个 <code>struct stack_frame</code> 类型的结构体指针 <code>stack_frame</code>，该结构体类型在 <code>cpuport.c</code> 中定义，具体代码如下：</p>

<pre><code class="language-c">struct exception_stack_frame
{
    /* 异常发生时自动保存的寄存器 */
    rt_uint32_t r0;
    rt_uint32_t r1;
    rt_uint32_t r2;
    rt_uint32_t r3;
    rt_uint32_t r12;
    rt_uint32_t lr;
    rt_uint32_t pc;
    rt_uint32_t psr;
};

struct stack_frame
{
    /* r4 ~ r11 register 异常发生时需手动保存的寄存器 */
    rt_uint32_t r4;
    rt_uint32_t r5;
    rt_uint32_t r6;
    rt_uint32_t r7;
    rt_uint32_t r8;
    rt_uint32_t r9;
    rt_uint32_t r10;
    rt_uint32_t r11;

    struct exception_stack_frame exception_stack_frame;
};
</code></pre>

<p>为了看懂栈的初始化过程，我们首先要明确一个问题：栈是从高地址向低地址生长的，在线程初始化时传进初始化函数的参数是栈的起始地址，即<strong>栈尾地址</strong>，栈的初始化首先需要根据栈尾地址和栈的大小确定<strong>栈首地址</strong>。计算栈首地址在线程初始化函数中调用栈初始化函数时计算并传给了栈初始化函数。线程控制块中的<strong>栈顶地址</strong>是当前栈的位置。</p>

<blockquote>
<p><strong>有一点不明白的是调用栈初始化函数时减掉了 4，在栈初始化函数中又加了回去，不明白这样处理的意义。</strong></p>
</blockquote>

<p>接着来看栈初始化函数，得到栈顶地址后，首先进行了向下 8 字节对齐。8 字节对齐的目的是为了后续实现浮点数的运算支持。向下是指当不满足 8 字节对齐时向下移动栈顶指针使其满足对齐要求，例如如果对齐前栈顶地址是 33 ，则对齐后的栈顶地址为 32，即空出一个 33 地址的位置不用。</p>


<figure class="center">
    
        <img src="/img/rt-thread-learning01/stk-stack.jpg" alt="完成栈地址字节对齐后的栈空间" />
    
    
    <figcaption>
        <h4>完成栈地址字节对齐后的栈空间</h4>
        
    </figcaption>
    
</figure>


<p>完成栈地址对齐后，接下来要<strong>对首次线程切换时用到的栈中的数据进行初始化</strong>。将栈地址向下移动 <code>sizeof(struct stack_frame)</code> 个地址，将 <code>stk</code> 指针强制转化为 <code>stack_frame</code> 类型后存到指针变量
<code>stack_frame</code> 中，这个时候 <code>stack_frame</code> 在线程栈里面的指向具体见下图：</p>


<figure class="center">
    
        <img src="/img/rt-thread-learning01/stack_frame-stack.jpg" alt="stack_frame 的栈空间" />
    
    
    <figcaption>
        <h4>stack_frame 的栈空间</h4>
        
    </figcaption>
    
</figure>


<p>接下来以 <code>stack_frame</code> 为起始地址，将栈空间里面的 <code>sizeof(struct stack_frame)</code> 个内存初始化为  <code>0xdeadbeef</code> 。将内存初始化为 <code>0xdeadbeef</code> 的原因是，这个数字是一个在嵌入式领域常用的魔力数，只是用来标识未使用的内存。接下来，设置线程初次运行时加载到 CPU 寄存器的环境参数。从栈顶开始，初始化的顺序固定，首先是异常发生时自动保存的 8 个寄存器，即 xPSR、R15、R14、R12、R3、R2、R1和 R0。其中 xPSR 寄存器的位 24 必须是 1，R15 PC 指针必须存的是线程的入口地址，R0 必须是线程形参，剩下的 R14、R12、R3、R2、 R1我们初始化为 0。完成初始化的栈空间如下图所示：</p>


<figure class="center">
    
        <img src="/img/rt-thread-learning01/inited-stack.jpg" alt="初始化完成后的栈空间" />
    
    
    <figcaption>
        <h4>初始化完成后的栈空间</h4>
        
    </figcaption>
    
</figure>


<p>最后栈初始化函数返回线程栈顶指针 <code>stk</code> ，线程初始化函数返回线程创建成功的错误码。关于错误码，其定义如下：</p>

<pre><code class="language-c">/* RT-Thread 错误码重定义 */
#define RT_EOK                          0               /**&lt; There is no error */
#define RT_ERROR                        1               /**&lt; A generic error happens */
#define RT_ETIMEOUT                     2               /**&lt; Timed out */
#define RT_EFULL                        3               /**&lt; The resource is full */
#define RT_EEMPTY                       4               /**&lt; The resource is empty */
#define RT_ENOMEM                       5               /**&lt; No memory */
#define RT_ENOSYS                       6               /**&lt; No system */
#define RT_EBUSY                        7               /**&lt; Busy */
#define RT_EIO                          8               /**&lt; IO error */
#define RT_EINTR                        9               /**&lt; Interrupted system call */
#define RT_EINVAL                       10              /**&lt; Invalid argument */

</code></pre>

<p>最后，回顾一下主函数中，调用线程初始化函数进行线程初始化的代码：</p>

<pre><code class="language-c">int main(void)
{   
    /* 硬件初始化 */
    /* 将硬件相关的初始化放在这里，如果是软件仿真则没有相关初始化代码 */   

    /* 初始化线程 */
    rt_thread_init( &amp;rt_flag1_thread,                 /* 线程控制块 */
                    flag1_thread_entry,               /* 线程入口地址 */
                    RT_NULL,                          /* 线程形参 */
                    &amp;rt_flag1_thread_stack[0],        /* 线程栈起始地址 */
                    sizeof(rt_flag1_thread_stack) );  /* 线程栈大小，单位为字节 */

    
    /* 初始化线程 */
    rt_thread_init( &amp;rt_flag2_thread,                 /* 线程控制块 */
                    flag2_thread_entry,               /* 线程入口地址 */
                    RT_NULL,                          /* 线程形参 */
                    &amp;rt_flag2_thread_stack[0],        /* 线程栈起始地址 */
                    sizeof(rt_flag2_thread_stack) );  /* 线程栈大小，单位为字节 */

}
</code></pre>

<h1 id="实现就绪列表">实现就绪列表</h1>

<p><strong>注：文中所有图片均来自《RT-Thread 内核实现与应用开发实战指南》。</strong></p>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"><a href="/about/" style="color:#2980B9;">luo</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2018-10-02</span>
  </p>
  <p class="copyright-item">
      <span class="item-title">原始文档</span>
      <span class="item-content"><a class="link-to-markdown" href="https://luozongtong123.github.io/post/rt-thread-learning01/index.md" target="_blank">Markdown 文件</a></span>
    </p>
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank">CC 署名 4.0 国际</a></span>
  </p>
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/rt-thread/">RT-Thread</a>
          
          <a href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
          
          <a href="/tags/%E6%A0%88/">栈</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/even-preview/">
            <span class="next-text nav-default">hugo 博客系统 even 主题预览</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  <div id="gitalk-container"></div>
  <link rel="stylesheet" href="/lib/gitalk/gitalk-1.2.2.min.css">
    <script src="/lib/gitalk/gitalk-1.2.2.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    id: '2018-09-29 09:37:14 \x2b0800 CST',
    title: 'RT-Thread 学习（一）',
    clientID: '773448aaf0a387786d40',
    clientSecret: 'fe42e33233fcdc37a7bcf12d8ef6c5868943e0ea',
    repo: 'luozongtong123.github.io',
    owner: 'luozongtong123',
    admin: ['luozongtong123'],
    body: decodeURI(location.href)
  });
  gitalk.render('gitalk-container');
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:luozongtong123@163.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/luozongtong123" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/luozongtong123" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="https://luozongtong123.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    
      2015 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author"><a href="/about/" style="color:#2980B9;">luo</a></span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>








</body>
</html>
